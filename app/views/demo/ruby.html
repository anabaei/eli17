<!DOCTYPE html>
 <script>
// $(window).load(function(){
//   while (1){
//   console.log("S_");
//      }
// });
 </script>



<html lang="en">
<head>
  <title>Ruby</title>
</head>

<body>

    <ins class="adsbygoogle"
               style="display:inline-block;width:728px;height:90px"
               data-ad-client="ca-pub-8784039367470812"
               data-ad-slot="9780252883"></ins>
          <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
          </script>  

<h2> Ruby  </h2>

<h3> Class </h3>
<p>A class is a blueprint or template or set of instructions to build a specific type of object. Every object is built from a class </p>



Run Ruby on a terminal single line 
<pre class="prettyprint lang-ruby">
ruby which # find where ruby located then run below code  
ruby -e "puts 323"
ruby -e "print 134"
ruby simple_file.rb
irb # take you to interactive ruby shell to type and test ruby codes in that environment, A good place to test exxisted methods like reverse
"hello".reverse
</pre>

Numbers 
<pre class="prettyprint lang-ruby">
10 / 3 --> 3 but
10.0 / 3 --> 3.3333333 OR 10 / 3.0 --> 3.3333333
</pre>

Strings
<pre class="prettyprint lang-ruby">
add strings --> var1 + ' and ' + var2
"amir"*2 --> "amiramir"
</pre>
use \ to escape chars

<h3> Hashes </h3>
<p>Hashes are object-indexed, unordered collection of objects. Values and keys can be anything from arrays to strings or numbers or mixed </p>
<pre class="prettyprint lang-ruby">
person_hash = {'first_key'=> 'Amir', 'Second_key' => '1999'}
To call first_key we have: person_hash['first_key']
Also we can return the key by having the value:  person_hash.index['Amir']
person_hash.keys   # returns keys
person_hash.values # returns valuse
person_hash.size = person_hash.length
person_hash['new_key'] = "new value"  #this code will add one pair to current hash
</pre>

<h3> Constant </h3>
(one difference with other languages) Any variable starts with a capital letter considered as a constant
<h3> Iterators </h3>
Iterators works like loops but instead of just looping and waiting for something to happen to know whether to continue loops or breaking out, iteratos traverse on a fixed size of data.
<pre class="prettyprint lang-ruby">
5.times do 
  puts "amir"
end  

fruits = ["apple", "banana",'orange']

fruits.each do |f|
  f.capitalize
end
</pre>


<img src=" <%= asset_path('varScope.png') %>" height="50%" width="50%">

<h3> Code Blocks </h3>
<p> In iterators or loops everything between do ... end or between {} are called code block. Variables define inside block are accessible only inside the block and we define it variable scope. </p>

<h3> Find </h3>
<p>  Go through of datas and if finds the block was true return the result</p>
(1..10).find { |i|  i % 3 == 0 }  # returns 3, the first one on the list

(1..10).include?(3)  # among numbers 1 to 10 which one include 3 ?

(1..10).find_all { |i|  i % 3 == 0 }  # returns all results

<h2> Helpers </h2>
<p> Helper methods defines inside Ruby module, every time we create a controller Rails generate a helper file to match. Also we can create custom helpers just file name and module name must be matched. Helpers are good place to store codes we need to call them more often, and avoid repeating codes, also to avoid complex codes in view we can use helpers.</p>



<h2> Ruby Module </h2>
<p>  Module are written same as classes and they have methods and variables. However, unlike classes, you can’t create objects based on Ruby modules and you can’t additionally subclass them as you can with actually Ruby classes. You can use module by adding its functions to other classes. </p>

<h2> REST </h2>
<p> Rails MVC pattern encourage us to break up controllers by model.  REST help to change how we talk with our resources(models) in an application. Map new URL syntax to controller actions and learn HTTP verb to talk with resources. Default routs using hashes.   </p>

<h3> HTTP Verbs </h3>
<p> Get is for links or getting information from server. Post only use to create an item, to update new item we use Put or Patch, Put is for when we want to update resource completely and patch is for when we update a portion of resource.</p>

<h3> Changes that REST requires in routing (RESTFUL Routs)</h3>
<p> Using Resources to handle seven of CRUD actions. It is a shortcut to map all standard routs to standard actions</p>
<pre class="prettyprint lang-ruby">
resources : subjects do 
  // customization
  end
</pre>
<p> URL plus each HTTP verbs leads to each action </p>

from lynda.com:
<img src=" <%= asset_path('table_rest.png') %>" height="50%" width="50%">
<p> REST links and forms helps us to have shorter paths instead of having controller action and id is equal to controllerName_path(id), and saves alot of typing </p>
<pre class="prettyprint lang-ruby">
{:controller => 'subject', :action => 'Show', :id => 5}
OR
Subject_path(5)
</pre>
from lynda.com:
<img src=" <%= asset_path('table_rest2.png') %>" height="50%" width="50%">
<h2> Relationship Types </h2>
<p> We could go by reading the value of a table foreign key, and then finding the related record by making a second query with a foreign key. That would be a valid approach, but it is tedious. It would be better if we could define the relationships between our models and therefore between our tables.</p>
<p>Active records provide us Associations. There are three main relational associations. One to one, one to many and many to many. </p>
<p> In one to one there is a parent and child, foriegn key goes to child table to point out parent and child belongs to parent and parent has one child. To access from parent to child Rails give us a magic code: parentName.ChildName which returns child name. for another way we use foreing key in child to find parent. Also to set a new child to parentobject we should just say : parentObject.Childname = ChildObject. Moreover child.parent returns the parent object.</p>
<p> One to many is same as one to one but each parents has many childs </p>
<p> Many to many we create a joint table to hold two foreing key, one for course for example one for students, so each students foreing key points out to a joint table which the pais of that key point out to the courses has second foriegn key </p>


Params are user specified data into application,

<h2> Inheritance in Ruby  </h2>
<p> There are three ways of inheritance in Ruby on Rails </p>
<li> Action in parents implied in childs </li>
<li> Action in childs override the same action in parent</li>
<li> Super() in child class, method call the parent</li>
This is a tutorial to the <a href="http://learnrubythehardway.org/book/ex44.html"> link </a>  </p>

































